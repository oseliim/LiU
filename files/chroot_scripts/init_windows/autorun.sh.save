#!/bin/bash
# Final GTK4 Autorun Script with Ubuntu Package Fix


set -e
set -x

# Ensure we run from the script directory so assets like image.jpg are found
cd "$(dirname "$0")"

# Mitigate blank window on some GPUs/drivers by forcing software rendering
export GSK_RENDERER="${GSK_RENDERER:-cairo}"

# Configuration
SOURCE_FILE="interface_simples_gtk.c"
OUTPUT_NAME="/usr/local/bin/win10/my_gtk_app"
GTK_VERSION=4

# Set environment paths
export PKG_CONFIG_PATH="/usr/lib/x86_64-linux-gnu/pkgconfig:/usr/local/lib/pkgconfig:/usr/share/pkgconfig:$PKG_CONFIG_PATH"
export LD_LIBRARY_PATH="/usr/lib/x86_64-linux-gnu:$LD_LIBRARY_PATH"

# Function to install GTK4 development files
install_gtk4() {
    echo "⛔ GTK4 não encontrado. Execute com privilégios: sudo ./script.sh"
    exit 1
}

# Function to verify GTK installation
verify_gtk_installation() {
    echo "🔍 Verifying GTK4 installation..."
    
    # Check pkg-config
    if ! pkg-config --exists gtk4; then
        echo "⚠️  pkg-config cannot find GTK4, checking manual paths..."
        
        # Check header files
        if [ ! -f "/usr/include/gtk-4.0/gtk/gtk.h" ]; then
            echo "❌ GTK4 headers not found in /usr/include/gtk-4.0/"
            echo "Trying to locate headers..."
            find /usr -name "gtk.h" | grep gtk-4.0 || {
                echo "❌ Could not find GTK4 headers"
                exit 1
            }
        fi
        
        # Check library files
        if [ ! -f "/usr/lib/x86_64-linux-gnu/libgtk-4.so" ]; then
            echo "❌ GTK4 library not found in /usr/lib/x86_64-linux-gnu/"
            echo "Trying to locate library..."
            find /usr -name "libgtk-4.so" || {
                echo "❌ Could not find GTK4 library"
                exit 1
            }
        fi
    else
        echo "✅ GTK4 development files verified via pkg-config"
    fi
}

# Function to build the project
build_project() {
    echo "🏗️ Building application..."
    
    # Get compilation flags
    CFLAGS=$(pkg-config --cflags gtk4 2>/dev/null || echo "-I/usr/include/gtk-4.0 -I/usr/include/glib-2.0 -I/usr/lib/x86_64-linux-gnu/glib-2.0/include")
    LIBS=$(pkg-config --libs gtk4 2>/dev/null || echo "-lgtk-4 -lgobject-2.0 -lglib-2.0")
    
    # Compile with explicit paths
    gcc "$SOURCE_FILE" -o "$OUTPUT_NAME" \
        $CFLAGS \
        -L/usr/lib/x86_64-linux-gnu \
        $LIBS
    
    # Verify binary was created
    if [ ! -f "$OUTPUT_NAME" ]; then
        echo "❌ Compilation failed - binary not created"
        exit 1
    fi
}

create_default_source() {
    if [ ! -f "$SOURCE_FILE" ]; then
        echo "📝 Creating default GTK4 application..."
        cat > "$SOURCE_FILE" << 'EOM'
#include <gtk/gtk.h>
#include <glib.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/wait.h>

// Global variables
static GtkProgressBar *progress_bar;
static GtkWindow *main_window;
static guint log_watch_id = 0;
static guint exit_timer_id = 0;
static GPid docker_pid = 0;
static GPid script_pid = 0;

// CSS for styling - white theme
const char *css = 
    ".progress-container {"
    "    background-color: white;"
    "    border-radius: 20px;"
    "    padding: 20px;"
    "    box-shadow: 0 4px 12px rgba(0,0,0,0.15);"
    "}"
    "progressbar {"
    "    border-radius: 10px;"
    "    min-height: 30px;"
    "}"
    "trough {"
    "    background-color: #f0f0f0;"
    "    border-radius: 10px;"
    "    border: 1px solid #ddd;"
    "}"
    "progress {"
    "    background-color: #4285F4;"
    "    border-radius: 10px;"
    "    box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);"
    "}"
    "label {"
    "    color: #444;"
    "    font-size: 16px;"
    "    font-weight: bold;"
    "    margin-top: 10px;"
    "}";

// Declarações antecipadas
static void start_docker_logs(void);
static void close_app(void);

// Close the application
static void close_app() {
    if (log_watch_id) {
        g_source_remove(log_watch_id);
        log_watch_id = 0;
    }
    if (exit_timer_id) {
        g_source_remove(exit_timer_id);
        exit_timer_id = 0;
    }
    if (docker_pid > 0) {
        kill(docker_pid, SIGTERM);
        waitpid(docker_pid, NULL, 0);
        docker_pid = 0;
    }
    if (script_pid > 0) {
        kill(script_pid, SIGTERM);
        waitpid(script_pid, NULL, 0);
        script_pid = 0;
    }
    if (main_window) {
        gtk_window_destroy(main_window);
    }
}

// Timer callback for exit
static gboolean exit_app(gpointer data) {
    (void)data;
    close_app();
    return G_SOURCE_REMOVE;
}

// Update progress bar and text
static void update_progress(double value, const char *text) {
    gtk_progress_bar_set_fraction(progress_bar, value);
    gtk_progress_bar_set_text(progress_bar, text);
    
    if (value >= 1.0) {
        g_print("Progress complete! Closing in 10 seconds...\n");
        exit_timer_id = g_timeout_add(10000, exit_app, NULL);
    }
}

// Read Docker logs and update progress
static gboolean read_docker_logs(GIOChannel *channel, GIOCondition condition, gpointer data) {
    (void)data;
    
    if (condition & G_IO_HUP) {
        g_print("Docker logs process ended.\n");
        return G_SOURCE_REMOVE;
    }

    if (condition & G_IO_IN) {
        gchar buffer[1024];
        gsize bytes_read;
        GError *error = NULL;
        
        GIOStatus status = g_io_channel_read_chars(channel, buffer, sizeof(buffer)-1, &bytes_read, &error);
        if (status == G_IO_STATUS_ERROR) {
            g_printerr("Error reading logs: %s\n", error->message);
            g_error_free(error);
            return G_SOURCE_REMOVE;
        }
        
        if (bytes_read > 0) {
            buffer[bytes_read] = '\0';
            g_print("%s", buffer);
            
            // Check for Docker errors
            if (strstr(buffer, "No such container")) {
                update_progress(0.0, "Error: Container 'windows' not found. Please run docker compose first.");
                g_print("Container 'windows' does not exist. Please ensure docker compose was executed successfully.\n");
                return G_SOURCE_REMOVE;
            }
            else if (strstr(buffer, "Error response from daemon")) {
                update_progress(0.0, "Error: Docker daemon error. Please check Docker service.");
                g_print("Docker daemon error detected.\n");
                return G_SOURCE_REMOVE;
            }
            else if (strstr(buffer, "Resizing disk")) {
                update_progress(0.5, "Resizing disk... (50%)");
            }
            else if (strstr(buffer, "Booting Windows")) {
                update_progress(0.7, "Booting Windows... (70%)");
            }
            else if (strstr(buffer, "Windows started succesfully")) {
                update_progress(1.0, "Windows started successfully! (100%)");
                return G_SOURCE_REMOVE;
            }
        }
    }
    
    return G_SOURCE_CONTINUE;
}

// Read script output and update progress
static gboolean read_script_output(GIOChannel *channel, GIOCondition condition, gpointer data) {
    (void)data;
    
    if (condition & G_IO_HUP) {
        g_print("Script execution completed.\n");
        start_docker_logs();
        return G_SOURCE_REMOVE;
    }

    if (condition & G_IO_IN) {
        gchar buffer[1024];
        gsize bytes_read;
        GError *error = NULL;
        
        GIOStatus status = g_io_channel_read_chars(channel, buffer, sizeof(buffer)-1, &bytes_read, &error);
        if (status == G_IO_STATUS_ERROR) {
            g_printerr("Error reading script output: %s\n", error->message);
            g_error_free(error);
            return G_SOURCE_REMOVE;
        }
        
        if (bytes_read > 0) {
            buffer[bytes_read] = '\0';
            g_print("%s", buffer);
            
            if (strstr(buffer, "Verificando dependências")) {
                update_progress(0.1, "Verifying dependencies... (10%)");
            }
            else if (strstr(buffer, "Verificando diretório docker_windows")) {
                update_progress(0.15, "Checking docker_windows directory... (15%)");
            }
            else if (strstr(buffer, "Extraindo ambiente Windows")) {
                update_progress(0.25, "Extracting Windows environment... (25%)");
            }
            else if (strstr(buffer, "docker compose up -d")) {
                update_progress(0.35, "Starting Docker services... (35%)");
            }
            else if (strstr(buffer, "docker start") && strstr(buffer, "windows")) {
                update_progress(0.4, "Starting Windows container... (40%)");
            }
            else if (strstr(buffer, "Aguardando inicialização do container")) {
                update_progress(0.45, "Waiting for container initialization... (45%)");
            }
        }
    }
    
    return G_SOURCE_CONTINUE;
}

// Start Docker logs process
static void start_docker_logs(void) {
    // Default sudo password if not provided by environment
    const char *pwd = getenv("DOCKER_SUDO_PASSWORD");
    if (pwd == NULL || *pwd == '\0') {
        // Do not overwrite if user already set; use default "aluno"
        setenv("DOCKER_SUDO_PASSWORD", "aluno", 0);
    }

    // Try docker without sudo, fallback to sudo -S using DOCKER_SUDO_PASSWORD
    gchar *cmd = g_strdup("docker logs -f windows || echo \"$DOCKER_SUDO_PASSWORD\" | sudo -S -p \"\" docker logs -f windows");
    gchar *argv[] = {"/bin/bash", "-lc", cmd, NULL};
    
    gint stdout_fd;
    gint stderr_fd;
    GError *error = NULL;
    
    gboolean success = g_spawn_async_with_pipes(
        NULL,
        argv,
        NULL,
        G_SPAWN_SEARCH_PATH,
        NULL,
        NULL,
        &docker_pid,
        NULL,
        &stdout_fd,
        &stderr_fd,
        &error
    );
    
    if (!success) {
        g_printerr("Error starting Docker logs: %s\n", error->message);
        g_error_free(error);
        update_progress(0.0, "Error: Failed to start Docker logs");
        g_free(cmd);
        return;
    }
    
    GIOChannel *channel = g_io_channel_unix_new(stdout_fd);
    g_io_channel_set_encoding(channel, NULL, NULL);
    g_io_channel_set_buffered(channel, FALSE);
    
    log_watch_id = g_io_add_watch(
        channel,
        G_IO_IN | G_IO_HUP,
        (GIOFunc)read_docker_logs,
        NULL
    );
    
    // Also monitor stderr for error messages
    GIOChannel *error_channel = g_io_channel_unix_new(stderr_fd);
    g_io_channel_set_encoding(error_channel, NULL, NULL);
    g_io_channel_set_buffered(error_channel, FALSE);
    
    g_io_add_watch(
        error_channel,
        G_IO_IN | G_IO_HUP,
        (GIOFunc)read_docker_logs,
        NULL
    );

    g_free(cmd);
}

// Start deployment script
static void start_deployment_script(void) {
    gchar *argv[] = {"/bin/bash", "./install_windows.sh", NULL};
    
    gint stdout_fd;
    GError *error = NULL;
    
    gboolean success = g_spawn_async_with_pipes(
        NULL,
        argv,
        NULL,
        G_SPAWN_SEARCH_PATH,
        NULL,
        NULL,
        &script_pid,
        NULL,
        &stdout_fd,
        NULL,
        &error
    );
    
    if (!success) {
        g_printerr("Error starting deployment script: %s\n", error->message);
        g_error_free(error);
        update_progress(0.0, "Error: Failed to start deployment script");
        return;
    }
    
    GIOChannel *channel = g_io_channel_unix_new(stdout_fd);
    g_io_channel_set_encoding(channel, NULL, NULL);
    g_io_channel_set_buffered(channel, FALSE);
    
    // Não precisamos armazenar o ID pois é temporário
    guint watch_id = g_io_add_watch(
        channel,
        G_IO_IN | G_IO_HUP,
        (GIOFunc)read_script_output,
        NULL
    );
    (void)watch_id; // Evita warning de variável não utilizada
}

// Key press event handler
static void on_key_pressed(GtkEventControllerKey *controller,
                           guint keyval,
                           guint keycode,
                           GdkModifierType state,
                           gpointer user_data) {
    (void)controller;
    (void)keycode;
    (void)user_data;
    
    if ((state & GDK_ALT_MASK) && (keyval == GDK_KEY_k)) {
        g_print("Alt+K pressed! Closing application...\n");
        close_app();
    }
}

// Create the application UI
static void activate(GtkApplication *app, gpointer user_data) {
    (void)user_data;
    
    main_window = GTK_WINDOW(gtk_application_window_new(app));
    gtk_window_set_title(main_window, "Windows Docker Deployment");
    gtk_window_fullscreen(main_window);
    
    GtkWidget *overlay = gtk_overlay_new();
    gtk_window_set_child(main_window, overlay);
    
    GtkWidget *background = NULL;
    
    if (g_file_test("image.jpg", G_FILE_TEST_EXISTS)) {
        background = gtk_picture_new_for_filename("image.jpg");
    } 
    else {
        g_printerr("image.jpg not found! Using fallback color.\n");
        background = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
        gtk_widget_set_name(background, "background-box");
        
        const char *fallback_css = "#background-box { background-color: #f0f0f0; }";
        GtkCssProvider *fallback_provider = gtk_css_provider_new();
        gtk_css_provider_load_from_data(fallback_provider, fallback_css, -1);
        gtk_style_context_add_provider(
            gtk_widget_get_style_context(background),
            GTK_STYLE_PROVIDER(fallback_provider),
            GTK_STYLE_PROVIDER_PRIORITY_APPLICATION
        );
    }
    
    gtk_widget_set_size_request(background, -1, -1);
    gtk_widget_set_hexpand(background, TRUE);
    gtk_widget_set_vexpand(background, TRUE);
    gtk_overlay_set_child(GTK_OVERLAY(overlay), background);
    
    GtkWidget *progress_container = gtk_box_new(GTK_ORIENTATION_VERTICAL, 10);
    gtk_widget_add_css_class(progress_container, "progress-container");
    gtk_widget_set_halign(progress_container, GTK_ALIGN_CENTER);
    gtk_widget_set_valign(progress_container, GTK_ALIGN_END);
    gtk_widget_set_margin_bottom(progress_container, 100);
    
    progress_bar = GTK_PROGRESS_BAR(gtk_progress_bar_new());
    gtk_progress_bar_set_show_text(progress_bar, TRUE);
    gtk_progress_bar_set_fraction(progress_bar, 0.0);
    gtk_widget_set_size_request(GTK_WIDGET(progress_bar), 600, 35);
    gtk_progress_bar_set_text(progress_bar, "Starting Windows deployment...");
    
    gtk_box_append(GTK_BOX(progress_container), GTK_WIDGET(progress_bar));
    
    GtkWidget *label = gtk_label_new("Press Alt+K to exit anytime");
    gtk_box_append(GTK_BOX(progress_container), label);
    
    gtk_overlay_add_overlay(GTK_OVERLAY(overlay), progress_container);
    
    GtkEventController *key_controller = gtk_event_controller_key_new();
    g_signal_connect(key_controller, "key-pressed", G_CALLBACK(on_key_pressed), NULL);
    gtk_widget_add_controller(GTK_WIDGET(main_window), key_controller);
    
    GtkCssProvider *provider = gtk_css_provider_new();
    gtk_css_provider_load_from_data(provider, css, -1);
    gtk_style_context_add_provider_for_display(
        gdk_display_get_default(),
        GTK_STYLE_PROVIDER(provider),
        GTK_STYLE_PROVIDER_PRIORITY_APPLICATION
    );
    
    start_deployment_script();
    gtk_widget_show(GTK_WIDGET(main_window));
}

int main(int argc, char **argv) {
    GtkApplication *app = gtk_application_new("com.example.dockermonitor", 0);
    g_signal_connect(app, "activate", G_CALLBACK(activate), NULL);
    
    int status = g_application_run(G_APPLICATION(app), argc, argv);
    
    if (log_watch_id) g_source_remove(log_watch_id);
    if (exit_timer_id) g_source_remove(exit_timer_id);
    
    if (docker_pid > 0) {
        kill(docker_pid, SIGTERM);
        waitpid(docker_pid, NULL, 0);
    }
    
    if (script_pid > 0) {
        kill(script_pid, SIGTERM);
        waitpid(script_pid, NULL, 0);
    }
    
    g_object_unref(app);
    
    return status;
}
EOM
    fi
}


# Main execution
main() {
    # Create source file if needed
    create_default_source
    
    # Verify or install GTK4
    if ! pkg-config --exists gtk4 && [ ! -f "/usr/include/gtk-4.0/gtk/gtk.h" ]; then
        install_gtk4
    else
        verify_gtk_installation
    fi
    
    # Build and run
    build_project
    echo "🚀 Launching application from /usr/local/bin/w10/..."
    #/usr/local/bin/w10/"$OUTPUT_NAME"
    #/"OUTPUT_NAME"
    $OUTPUT_NAME
}

main
