===============================================================================
                    DOCUMENTAÇÃO DA MODULARIZAÇÃO DO WIZARD LTSP
===============================================================================

DATA: 2024
VERSÃO: 1.0
AUTOR: Sistema de Modularização Automática

===============================================================================
                                SUMÁRIO
===============================================================================

1. VISÃO GERAL DA ARQUITETURA
2. ESTRUTURA DE MÓDULOS
3. DESCRIÇÃO DETALHADA DOS MÓDULOS
4. FLUXO DE COMUNICAÇÃO ENTRE MÓDULOS
5. FUNCIONALIDADES POR MÓDULO
6. DEPENDÊNCIAS E ORDEM DE CARREGAMENTO
7. PADRÕES DE DESENVOLVIMENTO
8. MANUTENÇÃO E EXTENSIBILIDADE
9. TROUBLESHOOTING
10. EXEMPLOS DE USO

===============================================================================
                        1. VISÃO GERAL DA ARQUITETURA
===============================================================================

A aplicação foi modularizada seguindo princípios de:
- Separação de Responsabilidades (Single Responsibility Principle)
- Baixo Acoplamento (Low Coupling)
- Alta Coesão (High Cohesion)
- Reutilização de Código
- Facilidade de Manutenção

ARQUITETURA MODULAR:
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│  WizardManager  │    │  NetworkModule  │    │  ImageModule    │
│   (Principal)   │◄──►│   (Rede)        │    │   (Imagem)      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│ UsersModule     │    │ SummaryModule   │    │InstallationModule│
│ (Usuários)      │    │ (Resumo/Aplicação)│  │ (Instalação)    │
└─────────────────┘    └─────────────────┘    └─────────────────┘

===============================================================================
                        2. ESTRUTURA DE MÓDULOS
===============================================================================

DIRETÓRIO: /static/js/modules/

├── WizardManager.js      (Módulo Principal - Coordenador)
├── NetworkModule.js      (Gerenciamento de Rede)
├── ImageModule.js        (Configuração de Imagem)
├── UsersModule.js        (Gerenciamento de Usuários)
├── SummaryModule.js      (Resumo e Aplicação)
├── InstallationModule.js (Instalação Inicial)
└── script.js            (Inicializador Principal)

===============================================================================
                    3. DESCRIÇÃO DETALHADA DOS MÓDULOS
===============================================================================

3.1 WIZARDMANAGER.JS
---------------------
RESPONSABILIDADES:
- Gerenciar estado atual do wizard
- Controlar navegação entre steps
- Manter dados do formulário centralizados
- Coordenar interações entre módulos

PRINCIPAIS MÉTODOS:
- initializeWizard(): Inicializa o wizard
- showStep(stepNumber): Mostra um step específico
- updateProgressIndicator(targetStep): Atualiza indicador visual
- handleNextStep(e): Manipula navegação para próximo
- handlePrevStep(): Manipula navegação para anterior
- validateCurrentStep(): Valida step atual
- getFormData(): Obtém dados do formulário
- updateFormData(section, data): Atualiza dados

3.2 NETWORKMODULE.JS
---------------------
RESPONSABILIDADES:
- Carregar e exibir informações de rede
- Validar configurações de rede
- Gerenciar modo de edição de rede
- Salvar alterações de configuração

PRINCIPAIS MÉTODOS:
- loadAndDisplayNetworkInfo(): Carrega dados de rede
- toggleEditMode(): Alterna modo edição/exibição
- saveNetworkChanges(): Salva alterações
- validateNetworkForm(): Valida formulário
- generateDisplayHTML(networkData): Gera HTML de exibição
- handleError(error): Manipula erros

3.3 IMAGEMODULE.JS
------------------
RESPONSABILIDADES:
- Gerenciar seleção de sistema operacional
- Controlar aplicativos opcionais
- Validar configurações de imagem
- Gerenciar ambiente gráfico

PRINCIPAIS MÉTODOS:
- toggleLinuxOptions(): Alterna opções Linux
- updateStep34NextBtn(): Atualiza estado do botão
- handleStep34Next(): Manipula próximo do step 3.4
- getSelectedApps(): Obtém aplicativos selecionados
- getImageConfig(): Obtém configurações de imagem
- validateImageConfig(): Valida configurações

3.4 USERSMODULE.JS
-------------------
RESPONSABILIDADES:
- Gerar usuários automaticamente com prefixo
- Validar campos de usuário
- Gerenciar campos dinâmicos de usuário
- Controlar visibilidade de senhas

PRINCIPAIS MÉTODOS:
- generateUsersWithPrefix(): Gera usuários automaticamente
- generateUserFields(): Gera campos dinamicamente
- validateUserFields(): Valida campos
- bindPasswordToggleEvents(): Vincula eventos de senha
- enableStep35NextBtn(): Habilita botão próximo
- getValidUsers(): Obtém usuários válidos

3.5 SUMMARYMODULE.JS
---------------------
RESPONSABILIDADES:
- Gerar resumo das configurações
- Aplicar configurações no servidor
- Gerenciar progresso de aplicação
- Exportar configurações

PRINCIPAIS MÉTODOS:
- populateSummary(): Popula resumo
- generateSummaryHTML(formData): Gera HTML do resumo
- handleConfirmSummary(): Manipula confirmação
- applyConfigurations(): Aplica configurações
- exportConfig(): Exporta configurações
- restartWizard(): Reinicia wizard

3.6 INSTALLATIONMODULE.JS
--------------------------
RESPONSABILIDADES:
- Executar instalação automática
- Gerenciar saída de instalação
- Controlar progresso de instalação
- Validar conclusão da instalação

PRINCIPAIS MÉTODOS:
- startInstallation(): Inicia instalação
- executeInstallation(): Executa script
- handleInstallationSuccess(): Manipula sucesso
- handleInstallationError(): Manipula erro
- markStepAsCompleted(): Marca step concluído
- fetchScriptOutput(): Busca saída de script

===============================================================================
                    4. FLUXO DE COMUNICAÇÃO ENTRE MÓDULOS
===============================================================================

4.1 PADRÃO DE COMUNICAÇÃO:
---------------------------
- WizardManager é o coordenador central
- Módulos se comunicam através de window.wizardManager
- Dados compartilhados via formData centralizado
- Eventos DOM para comunicação assíncrona

4.2 FLUXO DE DADOS:
--------------------
1. Usuário interage com interface
2. Módulo específico captura evento
3. Módulo valida dados localmente
4. Módulo atualiza formData via WizardManager
5. WizardManager propaga mudanças se necessário
6. Interface é atualizada

4.3 EXEMPLO DE FLUXO (Rede):
-----------------------------
1. NetworkModule.loadAndDisplayNetworkInfo()
2. Dados são buscados do servidor
3. NetworkModule.updateFormData(networkData)
4. WizardManager.formData.network é atualizado
5. Interface é atualizada com novos dados

===============================================================================
                    5. FUNCIONALIDADES POR MÓDULO
===============================================================================

5.1 WIZARDMANAGER - FUNCIONALIDADES:
-------------------------------------
✓ Navegação entre steps
✓ Controle de progresso visual
✓ Validação de steps
✓ Gerenciamento de estado
✓ Coordenação entre módulos
✓ Persistência de dados

5.2 NETWORKMODULE - FUNCIONALIDADES:
-------------------------------------
✓ Coleta automática de dados de rede
✓ Exibição de informações de rede
✓ Edição de configurações
✓ Validação de IPs e máscaras
✓ Salvamento de alterações
✓ Tratamento de erros

5.3 IMAGEMODULE - FUNCIONALIDADES:
----------------------------------
✓ Seleção de sistema operacional
✓ Controle de aplicativos opcionais
✓ Validação de configurações
✓ Gerenciamento de ambiente gráfico
✓ Toggle de opções Linux/Windows

5.4 USERSMODULE - FUNCIONALIDADES:
----------------------------------
✓ Geração automática de usuários
✓ Validação de nomes de usuário
✓ Controle de visibilidade de senhas
✓ Geração dinâmica de campos
✓ Validação de senhas
✓ Configuração de autologin

5.5 SUMMARYMODULE - FUNCIONALIDADES:
------------------------------------
✓ Geração de resumo completo
✓ Aplicação de configurações
✓ Controle de progresso
✓ Exportação de configurações
✓ Botões de edição no resumo
✓ Tratamento de erros de aplicação

5.6 INSTALLATIONMODULE - FUNCIONALIDADES:
-----------------------------------------
✓ Execução de instalação automática
✓ Controle de saída em tempo real
✓ Marcação de progresso
✓ Tratamento de erros de instalação
✓ Validação de conclusão

===============================================================================
                    6. DEPENDÊNCIAS E ORDEM DE CARREGAMENTO
===============================================================================

6.1 ORDEM DE CARREGAMENTO:
---------------------------
1. script.js (Inicializador)
2. WizardManager.js (Coordenador)
3. NetworkModule.js (Rede)
4. ImageModule.js (Imagem)
5. UsersModule.js (Usuários)
6. SummaryModule.js (Resumo)
7. InstallationModule.js (Instalação)

6.2 DEPENDÊNCIAS:
------------------
- Todos os módulos dependem do WizardManager
- SummaryModule depende de todos os outros módulos
- NetworkModule é independente
- ImageModule é independente
- UsersModule é independente
- InstallationModule é independente

6.3 INICIALIZAÇÃO:
------------------
```javascript
// Ordem de inicialização
window.wizardManager = new WizardManager();
window.networkModule = new NetworkModule();
window.imageModule = new ImageModule();
window.usersModule = new UsersModule();
window.summaryModule = new SummaryModule();
window.installationModule = new InstallationModule();
```

===============================================================================
                    7. PADRÕES DE DESENVOLVIMENTO
===============================================================================

7.1 PADRÕES UTILIZADOS:
-----------------------
- Module Pattern (Padrão de Módulo)
- Observer Pattern (Padrão Observador)
- Factory Pattern (Padrão Fábrica)
- Singleton Pattern (Padrão Singleton para WizardManager)

7.2 CONVENÇÕES DE CÓDIGO:
--------------------------
- Classes começam com maiúscula
- Métodos em camelCase
- Constantes em UPPER_SNAKE_CASE
- Comentários JSDoc obrigatórios
- Tratamento de erros consistente

7.3 ESTRUTURA DE CLASSE:
-------------------------
```javascript
class ModuleName {
    constructor() {
        this.elements = { /* elementos DOM */ };
        this.bindEvents();
    }
    
    bindEvents() {
        // Vincula eventos
    }
    
    // Métodos públicos
    // Métodos privados (com _)
}
```

7.4 TRATAMENTO DE ERROS:
-------------------------
- Try/catch em operações assíncronas
- Validação de elementos DOM
- Mensagens de erro informativas
- Fallbacks para funcionalidades críticas

===============================================================================
                    8. MANUTENÇÃO E EXTENSIBILIDADE
===============================================================================

8.1 ADICIONANDO NOVOS MÓDULOS:
-------------------------------
1. Criar arquivo no diretório /modules/
2. Seguir padrão de classe estabelecido
3. Adicionar ao script.js
4. Inicializar no initializeModules()
5. Documentar funcionalidades

8.2 MODIFICANDO MÓDULOS EXISTENTES:
------------------------------------
- Manter interface pública estável
- Adicionar novos métodos sem quebrar existentes
- Documentar mudanças
- Testar integração

8.3 DEBUGGING:
--------------
```javascript
// Função de debug disponível
window.listActiveModules();

// Verificar módulos ativos
console.log(window.wizardManager);
console.log(window.networkModule);
// etc...
```

8.4 LOGS E MONITORAMENTO:
-------------------------
- Console.log para debug
- Tratamento de erros com console.error
- Logs de inicialização de módulos
- Logs de operações críticas

===============================================================================
                    9. TROUBLESHOOTING
===============================================================================

9.1 PROBLEMAS COMUNS:

PROBLEMA: "Módulo não encontrado"
SOLUÇÃO: Verificar se arquivo existe em /modules/
         Verificar ordem de carregamento

PROBLEMA: "Elementos DOM não encontrados"
SOLUÇÃO: Verificar se elementos existem na página
         Adicionar verificações de null

PROBLEMA: "Comunicação entre módulos falhando"
SOLUÇÃO: Verificar se WizardManager está inicializado
         Verificar se formData está sendo atualizado

PROBLEMA: "Eventos não funcionando"
SOLUÇÃO: Verificar se bindEvents() está sendo chamado
         Verificar se elementos existem no DOM

9.2 DEBUGGING AVANÇADO:
-----------------------
```javascript
// Verificar estado do wizard
console.log(window.wizardManager.getFormData());

// Verificar módulos ativos
window.listActiveModules();

// Verificar elementos DOM
console.log(document.getElementById('step-content'));
```

===============================================================================
                    10. EXEMPLOS DE USO
===============================================================================

10.1 ADICIONANDO NOVA FUNCIONALIDADE:
-------------------------------------
```javascript
// Em um novo módulo
class NewModule {
    constructor() {
        this.elements = {
            // elementos DOM
        };
        this.bindEvents();
    }
    
    bindEvents() {
        // eventos
    }
    
    // métodos
}

// No script.js
window.newModule = new NewModule();
```

10.2 COMUNICANDO ENTRE MÓDULOS:
--------------------------------
```javascript
// De um módulo para outro
const wizardManager = window.wizardManager;
wizardManager.updateFormData('section', data);

// Obtendo dados de outro módulo
const formData = wizardManager.getFormData();
```

10.3 ADICIONANDO VALIDAÇÃO:
---------------------------
```javascript
// Em qualquer módulo
validateForm() {
    const isValid = this.checkValidation();
    if (!isValid) {
        this.showError();
        return false;
    }
    return true;
}
```

===============================================================================
                                CONCLUSÃO
===============================================================================

A modularização realizada oferece:

✓ MELHOR ORGANIZAÇÃO: Código dividido por responsabilidades
✓ FACILIDADE DE MANUTENÇÃO: Módulos independentes
✓ REUTILIZAÇÃO: Módulos podem ser reutilizados
✓ TESTABILIDADE: Cada módulo pode ser testado isoladamente
✓ EXTENSIBILIDADE: Fácil adição de novos módulos
✓ DEBUGGING: Melhor rastreamento de problemas
✓ DOCUMENTAÇÃO: Código bem documentado

Esta arquitetura modular torna o sistema mais robusto, 
manutenível e escalável para futuras expansões.

===============================================================================
                                FIM DA DOCUMENTAÇÃO
=============================================================================== 